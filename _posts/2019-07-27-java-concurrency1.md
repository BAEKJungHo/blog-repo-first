---
title: "Concurrency"
layout: post
category: Java
tags: [Java]
excerpt: "Java의 Concurrency 역사에 대해서 배워 봅시다."
author: BAEKJungHo
---

* content
{:toc}

## 자바 동시성

  > “Objects are abstractions of processing. Threads are abstractions of schedule.” — James O. Coplien

  Java 동시성 은 Java 플랫폼에서 `다중 스레드, 동시성 및 병렬 처리`를 다루는 용어입니다. 여기에는 Java 동시성 도구, 문제점 및 솔루션이 포함됩니다. 이 Java 동시성 튜토리얼에서는 Java에서 멀티 스레딩과 관련된 멀티 스레딩, 동시성 구조, 동시성 문제, 비용, 이점의 핵심 개념을 다룬다.

  Java는 개발자가 멀티 스레딩을 쉽게 사용할 수있게 해주는 최초의 언어 중 하나였다.

  Java는 처음부터 멀티 스레딩 기능을 갖추고있었다.

## 왜 Concurrency가 필요한가?

  Concurrency는 단일 스레드에서 엮여 있던 “무엇(What)을 할 것인가”와 “언제(When) 끝날 것인가”간의 Coupoing을 해소시켜 준다. 이는 처리량과 구조 개선에 도움을 줄 수 있다. 거대한 하나의 Loop가 아니라 작은 협력 프로그램 여럿으로 나눌 수 있으며 이해하기 쉽고 문제를 분리하기 쉽다.

  처리량 또한 향상될 수 있다. 한 유저의 요청을 처리하는 데에 1초가 필요한 시스템을 생각해 보자. 이 시스템은 적은 유저가 사용할 경우 그럭저럭 괜찮은 퍼포먼스를 보여줄 것이다. 하지만 유저가 늘어남에 따라 모든 유저는 자신보다 먼저 도착한 요청이 끝날 때까지 기다려야만 한다. 이러한 경우 concurrency가 여러 유저를 동시에 처리함으로써 처리량을 향상시킬 수 있다.

### 미신과 오해

  - `Concurrency는 항상 퍼포먼스를 향상시킨다.`
    - 항상 그런 것만은 아니다. Concurrency는 여러 스레드 혹은 여러 프로세서가 대기 시간을 공유할 수 있는 경우에만 퍼포먼스를 향상시킨다. 하지만 이러한 경우는 드물다. 또한 Context Switching이 일어나기 때문에 퍼포먼스, 코드 작성 양쪽 모두에 약간의 오버헤드를 일으킨다.

  - `Concurrency는 시스템의 디자인을 변경시키지 않는다.`
    - `무엇`과 `언제`를 분리하는 작업은 보통 시스템의 구조에 큰 영향을 미친다. Concurrency 문제에는 보통 근본적인 디자인 개편이 필요하다.

  - `Web이나 EJB와 같은 컨테이너를 사용한다면 Concurrency 문제들은 신경쓸 필요가 없다.`
    - 컨테이너가 어떤 일을 하는가에 대해 알아야 하며 Concurrency update, Deadlock을 해결하는 방법을 알아야 한다.

  > Concurrency 관련 버그는 재현하기 어렵기 때문에 종종 one-off 2로 취급된다.

## Multi Threading(멀티 스레딩)

  > Wikipedia
  >
  > 멀티스레딩(multithreading) 컴퓨터는 여러 개의 스레드를 효과적으로 실행할 수 있는 하드웨어 지원을 갖추고 있다. 이는 스레드가 모두 같은 주소 공간에서 동작하여 하나의 CPU 캐시 공유 집합과 하나의 변환 색인 버퍼 (TLB)만 있는 멀티프로세서 시스템 (멀티 코어 시스템)과는 구별한다. 그러므로 멀티스레딩은 프로그램 안에서 병렬 처리의 이점을 맛볼 수 있지만 멀티프로세싱 시스템은 여러 개의 프로그램들을 병렬로 처리할 수 있다. 멀티프로세싱 시스템이 여러 개의 완전한 처리 장치들을 포함하는 반면 멀티스레딩은 스레드 수준뿐 아니라 명령어 수준의 병렬 처리에까지 신경을 쓰면서 하나의 코어에 대한 이용성을 증가하는 것에 초점을 두고 있다.

  즉, 멀티 스레딩이란 __하나의 프로세스를 다수의 실행 단위로 구분__ 하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 멀티스레딩이라고 한다.

  __하나의 프로그램에 동시에 여러개의 일을 수행할수 있도록 해주는 것이다.__

  ![mt1](/images/posts/201907/mt1.jpg)

### 장단점

  - 장점
    - `응답성`
      - 대화형 프로그램을 멀티스레드화하면, 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이 계속되어, 사용자에 대한 응답성이 증가된다. 예를 들어, 멀티스레드가 적용된 웹 브라우저 프로그램에서 하나의 스레드가 이미지 파일을 로드하고 있는 동안, 다른 스레드에 사용자와의 상호 작용이 가능하다.
      - 심지어 쓰레드의 문맥 교환은 프로세스 문맥 교환과는 달리 `캐시 메모리를 비울 필요가 없기 때문`에 더 빠르다.

    - `자원 공유`
      - 스레드는 자동적으로 그들이 속한 프로세스의 자원들과 메모리를 공유한다. 코드 공유의 이점은, 한 응용 프로그램이 같은 주소 공간 내에 여러 개의 다른 활동성 스레드를 가질 수 있다는 점이다.
      - 쓰레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 `전역 변수의 공간` 또는 동적으로 할당된 공간인 `힙(Heap) 영역`을 이용하여 데이터를 주고받을 수 있다.
      - 따라서, `데이터 영역과 힙 영역을 통해 데이터 교환이 가능`하다. 쓰레드 사이에서의 데이터 교환에서는 특별한 기법이 필요없다.

    - `경제성`
      - 프로세스 생성에 메모리와 자원을 할당하는 것은 비용이 많이 든다. 스레드는 자신이 속한 프로세스의 자원들을 공유하기 때문에, 스레드를 생성하고 문맥교환을 하는 편이 보다 경제적이다.

    - `멀티프로세서 활용`
      - 멀티프로세서 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다. 단일 스레드 프로세스는 CPU가 많아도 CPU 한개에서만 실행된다. 즉, 다중 스레드화를 하면 다중 CPU에서 병렬성이 증가된다.

  - 단점
    - 다중 스레드는 캐시나 변환 색인 버퍼(TLB)와 같은 하드웨어 리소스를 공유할 때 서로를 간섭할 수 있다.
    - 하나의 스레드만 실행 중인 경우 싱글 스레드의 실행 시간이 개선되지 않고 오히려 지연될 수 있다.
    - 멀티스레딩의 하드웨어 지원을 위해 응용 프로그램과 운영 체제 둘 다 충분한 변화가 필요하다.
    - 스레드 스케줄링은 멀티스레딩의 주요 문제이기도 하다.

### Multi Process와의 차이점

  - 멀티 프로세스 : [데이터 영역, 힙, 스택 ]영역 모두를 비공유

  - 멀티 쓰레드 : [ 데이터 영역, 힙, 스택 ]영역중 스택 영역만 비공유


## 참조

  > [http://tutorials.jenkov.com/java-concurrency/index.html](http://tutorials.jenkov.com/java-concurrency/index.html)
  >
  > [https://nesoy.github.io/articles/2018-04/CleanCode-ConCurrency](https://nesoy.github.io/articles/2018-04/CleanCode-ConCurrency)
  >
  > [https://goodgid.github.io/What-is-Multi-Thread/](https://goodgid.github.io/What-is-Multi-Thread/)
